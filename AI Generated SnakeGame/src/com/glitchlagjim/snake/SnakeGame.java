package com.glitchlagjim.snake;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.Timer;

import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Random;

/**
 * This program is AI Generated. As it came out very recently, I was interested in the
 * capabilities and pitfalls of AI generated code. Using ChatGPT, I created this program
 * in various steps. It could not write the entire program for me from scratch, but with
 * multiple queries I was able to get it to build various pieces of the program. The main
 * observations I made from this project are as follows:
 * 		- The AI often seems to forget some of what it has already generated and creates bugs
 * 		  due to this. It will sometimes think it has generated some code that it hasn't yet and
 * 		  give me references to something that doesn't exist. I believe this will be solved fairly
 * 		  easily as programs specifically made for generating code are created. ChatGPT is not
 * 		  the most conducive environment for AI generated coding as it doesn't have a dedicated
 * 		  code file which it is working on, but has to determine what code you did and didn't like
 * 		  that it has already generated.
 * 		- Without approach and design guidance from an expert, the program will decide on an approach
 * 		  that is often questionable. In this project there are things that I would never have designed
 * 		  the way the AI wrote it. You can ask the AI to fix things like this, but it usually
 * 		  requires very specific instructions on how to do so. Often it is faster to just program those
 * 		  things yourself (but not always).
 * 		- Often the AI will generate inefficient code, or leave an old variable you asked it to remove
 * 		  in future generated code. This will likely be fixed to some degree in the future with
 * 		  programs specifically dedicated and optimized for different programming languages. However,
 * 		  the efficiency of the code written may not be so easily fixed. For the time being, at least,
 * 		  I believe that an expert will need to examine AI code carefully for better algorithmic approaches.
 * 		- AI generated code can only produce as good a result as the information given it. It is
 * 		  not a person and garbage in will cause garbage out. Because of this, real world programs would
 * 		  need an incredible amount of information given to create the program correctly. For the time being
 * 		  AI generated code seems to be mostly useful for asking simple algorithmic questions, not complex
 * 		  programs, as there could potentially be more work to get the AI to generate code than to write
 * 		  it yourself (if you know what you are doing). That said, in the near future I would predict
 * 		  this will somewhat change. Not to the point that a Software Engineer is not needed, but to the
 * 		  point that the AI will greatly speed up the work of the Software Engineer allowing him/her
 * 		  to do the work of 2+ people by themselves.
 * 		- While this AI is a massive breakthrough, I believe it will require another breakthrough to
 * 		  create an AI that can actually REPLACE the Software Engineer. A lot more coding-specific data
 * 		  will be needed and the various coding solutions would have to be verified to work. I think to
 * 		  get to this point we need a large data-set of professional, working programs as well as a large
 * 		  data-set of programming questions and answers. Stack overflow is a great resource for questions
 * 		  and answers, but it is currently flawed in that many answers are often wrong or not the best solution.
 * 		  We would need professionally scanned questions and answers for the data-set for the best results.
 * 		  In terms of large, professional programs, I think it would be difficult to get companies to
 * 		  allow their intellectual property to be used in this manner. While it would likely allow for a
 * 		  massive breakthrough in AI capabilities, it would also expose those companies to massive security
 * 		  risks. Perhaps programs being sunset would be a possibility, but even there companies would likely
 * 		  be very reluctant. It also would reduce the quality of the data-sets to some degree because the
 * 		  applications used would likely be quite old (using potentially out-dated syntax, missing new
 * 		  program language features), and using programming languages that may be going out of style/not
 * 		  being used as much in industry any longer.
 * 
 * Note: Inline comments (//) are generated by the AI, but multi-line comments (/**) are written by me as
 *       thoughts, comments, and ideas about the code generated.
 * 
 * @version 1.0
 * @author andzedwick
 *
 */
public class SnakeGame extends JPanel implements ActionListener, KeyListener {

	private static final long serialVersionUID = -8508830811901599964L;
	
	/**
	 * I had to ask the AI to create many of the class variables listed here because
	 * they were being hard-coded into the program. This caused difficulty in updating these
	 * values to tweak the program. Not just on the human side, but if I asked the AI to update
	 * them, it had a chance of missing some, updating other things I didn't want it to, or doing
	 * odd things with logic such as setting another variable to the new final variable and then
	 * using the new variable reference instead of the final variable. Or it could just leave variables
	 * that are unused in the code.
	 */
	private final int CELL_SIZE = 20;
	private final int FRAME_SIZE = 1000;
	private final int BOARD_SIZE = (FRAME_SIZE/CELL_SIZE);
	private final int FOOD_VALUE = 2;
	private final int WALL_VALUE = -2;
	private final int SNAKE_SPAWN_LOCATION = (BOARD_SIZE/2);
	private final int MIN_SPEED = 1;
	private final int MAX_SPEED = 400;

	private int[][] board;
	private int snakeX;
	private int snakeY;
	private int prevX;
	private int prevY;
	private int dx = 0;
	private int dy = 0;
	private int score;
	private int speed = MAX_SPEED;

	private Random rand = new Random();
	private Timer timer;
	private ArrayList<Integer> snakeTailX = new ArrayList<>();
	private ArrayList<Integer> snakeTailY = new ArrayList<>();
	private ArrayList<Point> wallPositions = new ArrayList<>();

    /**
     * Constructor setting up the GUI and adding timer to control snake movement speed.
     * 
     * The AI choice to use a timer is interesting. For this program I personally would
     * have used a long to store current and last times using System.nanoTime(). The difference
     * along with a variable to hold the current speed could then be used to control the snake
     * movement and game update speed separately. While this may appear more complex in the code,
     * it would reduce a lot of overhead in the Timer() class which would increase program speed.
     */
    public SnakeGame() {
        // Set the size of the panel
        setPreferredSize(new Dimension(FRAME_SIZE, FRAME_SIZE));
        setBackground(Color.BLACK);

        // Initialize the board
        snakeX = SNAKE_SPAWN_LOCATION;
        snakeY = SNAKE_SPAWN_LOCATION;

        board = new int[BOARD_SIZE][BOARD_SIZE];
        board[snakeX][snakeY] = 1;
        generateFood();

        // Start the timer
        timer = new Timer(speed, this);
        timer.start();

        // Add the key listener
        addKeyListener(this);
        setFocusable(true);
    }

    /**
     * Paints the JPanel on the JFrame.
     * 
     * I liked the approach the AI took on this method. It took a little coercing to get it to
     * draw thing with a consistent approach, but the original method of drawing the grid which
     * I continued asking it to use is a good one for a simple application. For maximum efficiency
     * (which is not necessary in this small game) more complex code could be written to only re-draw
     * updated board tiles. This would require a small amount more memory, but would be far faster
     * in execution.
     */
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Draw the grid
        for (int i = 0; i < BOARD_SIZE; i++) {
            for (int j = 0; j < BOARD_SIZE; j++) {
                if (board[i][j] == 1) {
                    g.setColor(Color.GREEN);
                    g.fillRect(i * CELL_SIZE + 1, j * CELL_SIZE + 1, CELL_SIZE - 1, CELL_SIZE - 1);
                    g.setColor(Color.BLACK);
                } else if (board[i][j] == 0) {
                    g.setColor(Color.BLACK);
                    g.fillRect(i * CELL_SIZE + 1, j * CELL_SIZE + 1, CELL_SIZE - 1, CELL_SIZE - 1);
                } else if (board[i][j] == FOOD_VALUE) {
                    g.setColor(Color.RED);
                    g.fillRect(i * CELL_SIZE + 1, j * CELL_SIZE + 1, CELL_SIZE - 1, CELL_SIZE - 1);
                    g.setColor(Color.BLACK);
                } else if (board[i][j] == WALL_VALUE) {
                    g.setColor(Color.GRAY);
                    g.fillRect(i * CELL_SIZE + 1, j * CELL_SIZE + 1, CELL_SIZE - 1, CELL_SIZE - 1);
                    g.setColor(Color.BLACK);
                }
            }
        }
        
        for (int i = 0; i < snakeTailX.size(); i++) {
            g.setColor(Color.YELLOW);
            g.fillRect(snakeTailX.get(i) * CELL_SIZE + 1, snakeTailY.get(i) * CELL_SIZE + 1, CELL_SIZE - 1, CELL_SIZE - 1);
        }
        
        // Draw the score
        g.setColor(Color.WHITE);
        g.setFont(new Font("Arial", Font.BOLD, 16));
        g.drawString("Score: " + score, FRAME_SIZE - 100, 20);
        g.drawString("Speed: " + (MAX_SPEED - speed + 10), 10, 20);
    }
    
    @Override
    public void actionPerformed(ActionEvent e) {
        // Move the snake
        move();
        repaint();
    }

    /**
     * The AI really struggled to get this method right and it took me a lot of time
     * to get it to create working code. I surmise that it was getting confused about
     * what order the code should be in. The AI generates what it thinks is best for each
     * next word/character (as far as I understand it). Since it is not a really a compiler
     * this can cause issues (although that will easily be fixed in dedicated programs for
     * generating code). It also doesn't actually understand the programming logic it is writing.
     * I believe when software is written specifically for writing code, if it is programmed
     * to go through it's own code to search for logic errors and bugs (including having a compiler
     * to check it's work), then this issue would be fixed. This issue is a pretty big deal as it
     * causes the programmer to go through all the written code and debug it very carefully to find
     * errors that could be avoided.
     */
    public void move() {
        prevX = snakeX;
        prevY = snakeY;
        
        // Update the snake's position
        snakeX += dx;
        snakeY += dy;

        // Remove the previous position of the snake's head
        board[prevX][prevY] = 0;

        // Check for collision
        if (snakeX < 0 || snakeX > BOARD_SIZE-1 || snakeY < 0 || snakeY > BOARD_SIZE-1) {
            endGame();
        }
        
        // Check for collision with walls
        if (board[snakeX][snakeY] == WALL_VALUE) {
            JOptionPane.showMessageDialog(null, "Game Over! Your score was: " + score);
            endGame();
        }
        
        // Check if the snake hit the food
        if (board[snakeX][snakeY] == FOOD_VALUE) {
            score++;
            generateWalls();
            generateFood();
            speed = (int) (speed/1.2f);
        }

        // check if the speed is lower than MIN_SPEED
        if (speed < MIN_SPEED) {
            speed = MIN_SPEED;
        }

        // Update the tail
        snakeTailX.add(0, prevX);
        snakeTailY.add(0, prevY);

        // Remove the last segment of the tail
        if (snakeTailX.size() > score) {
            snakeTailX.remove(snakeTailX.size() - 1);
            snakeTailY.remove(snakeTailY.size() - 1);
        }

        board[snakeX][snakeY] = 1;
        
        for (int i = 0; i < snakeTailX.size(); i++) {
            if (snakeX == snakeTailX.get(i) && snakeY == snakeTailY.get(i)) {
                endGame();
            }
        }
        setSpeed(speed);
    }
    
    /**
     * As mentioned before, using a Timer is not a good option for moving the snake
     * due to overhead. This is a great example of why. Every time the speed is updated
     * a whole new timer is being created and started after stopping the previous timer.
     * @param newSpeed
     */
    public void setSpeed(int newSpeed) {
        speed = newSpeed;
        timer.stop();
        timer = new Timer(speed, this);
        timer.start();
    }
    
    /**
     * This was originally generated as inline code in move (with if statements). This shows another
     * issue with AI generated code - organization. Just because it works doesn't mean it's readable
     * and debugable. Often code would be repeated by the AI all over the place instead of just
     * creating a method. This would need to be solved in a dedicated AI programming software. It also
     * needs to be watched out for carefully by the Software Engineer.
     */
    private void generateFood(){
    	// Find an empty cell for the food
        int foodX;
        int foodY;
        do {
            foodX = rand.nextInt(BOARD_SIZE);
            foodY = rand.nextInt(BOARD_SIZE);
        } while (board[foodX][foodY] != 0);
        
        board[foodX][foodY] = FOOD_VALUE;
    }
    
    public void generateWalls() {
        // Clear any existing walls
        for (Point wallPos : wallPositions) {
            board[wallPos.x][wallPos.y] = 0;
        }
        wallPositions.clear();

        int numWalls = rand.nextInt(5) + 3; // Generate between 3 and 7 walls
        for (int i = 0; i < numWalls; i++) {
            int wallX = rand.nextInt(BOARD_SIZE);
            int wallY = rand.nextInt(BOARD_SIZE);
            int wallLength = rand.nextInt(BOARD_SIZE / 2) + 1;
            boolean isVertical = rand.nextBoolean();

            // Check if the wall position is valid
            boolean validPos = true;
            for (int j = 0; j < wallLength; j++) {
                if (isVertical) {
                    if (wallX + j >= BOARD_SIZE) {
                        validPos = false;
                        break;
                    }
                    if (board[wallX + j][wallY] != 0) {
                        validPos = false;
                        break;
                    }
                    if (Math.abs(wallX + j - snakeX) < 8 && Math.abs(wallY - snakeY) < 8) {
                        validPos = false;
                        break;
                    }
                } else {
                    if (wallY + j >= BOARD_SIZE) {
                        validPos = false;
                        break;
                    }
                    if (board[wallX][wallY + j] != 0) {
                        validPos = false;
                        break;
                    }
                    if (Math.abs(wallX - snakeX) < 8 && Math.abs(wallY + j - snakeY) < 8) {
                        validPos = false;
                        break;
                    }
                }
            }

            if (validPos) {
                for (int j = 0; j < wallLength; j++) {
                    if (isVertical) {
                        board[wallX + j][wallY] = WALL_VALUE;
                        wallPositions.add(new Point(wallX + j, wallY));
                    } else {
                        board[wallX][wallY + j] = WALL_VALUE;
                        wallPositions.add(new Point(wallX, wallY + j));
                    }
                }
            }
        }
    }
    
    private void endGame() {
        int restart = JOptionPane.showOptionDialog(null, "Game Over! Your Score is: " + score + ". Your ending speed was: " + (MAX_SPEED - speed + 10) + ".", "Restart?", JOptionPane.YES_NO_OPTION, JOptionPane.INFORMATION_MESSAGE, null, null, null);
        if (restart == JOptionPane.YES_OPTION) {
            restartGame();
        } else if (restart == JOptionPane.NO_OPTION) {
            System.exit(0);
        }
    }
    
    public void restartGame() {
        snakeX = SNAKE_SPAWN_LOCATION;
        snakeY = SNAKE_SPAWN_LOCATION;
        dx = 0;
        dy = 0;
        score = 0;
        speed = MAX_SPEED;
        setSpeed(speed);
        board = new int[BOARD_SIZE][BOARD_SIZE];
        snakeTailX.clear();
        snakeTailY.clear();
        board[snakeX][snakeY] = 1;
        generateFood();
    }


    @Override
    public void keyTyped(KeyEvent e) {
    }

    /**
     * This method of key detection is good, but missing something. Note that you can
     * completely reverse the direction of your snake (left to right/top to bottom) and
     * run into yourself. This is an issue if you are clicking the arrow keys quickly.
     * You can go from left to up to right all within the same movement update. In the end,
     * when the snake updates direction, it ends up going from left to right instantly
     * and collides with itself and dies. I left this design flaw as an example of the types
     * of issues you would have to deal with from AI generated code. This is a design flaw that
     * AI wouldn't be able to detect (it isn't actually thinking) and a Software Engineer would
     * need to catch and fix. More testing is required for AI generated code for sure.
     */
    @Override
    public void keyPressed(KeyEvent e) {
        // Update the direction of the snake's movement based on the key pressed
        if (e.getKeyCode() == KeyEvent.VK_UP) {
            dx = 0;
            dy = -1;
        } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
            dx = 0;
            dy = 1;
        } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            dx = -1;
            dy = 0;
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
        	dx = 1;
        	dy = 0;
        }
    }
    
    @Override
    public void keyReleased(KeyEvent e) {
    }

    /**
     * The AI decided to put some of the initialization code in the main() method.
     * This is logically inconsistent and splits up the code which could confuse
     * anyone trying to debug, understand, or update the codebase. This should be
     * in the constructor.
     * 
     * @param args
     */
    public static void main(String[] args) {
        JFrame frame = new JFrame("Snake Game - v1 (Created by andzedwick)");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setResizable(false);
        frame.add(new SnakeGame());
        frame.pack();
        frame.setVisible(true);
        frame.setLocationRelativeTo(null);
    }
}

